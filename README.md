# Systems-Programming
This repository showcases my journey through the CS 2200 curriculum, focusing on processor design and systems programming. It includes five projects, each documented with detailed explanations of the design process, challenges faced, and insights gained.

[DISCLAIMER]
All projects past the second were completed much earlier than when committed to this repository. To be completely honest, I was far too engrossed with reading my textbook and writing code to find the time to upload my finished projects. 

## Project 1 - Implementing a 16-bit LC-2200 Datapath
This was a fun, hands-on way of creating a processor mostly from scratch. While I obtained a general understanding of datapath design from a prerequisite course offered at my college (CS 2110), how the control unit facilitates the processor stepping through sequential, repeatable states remained a mystery to me until now. That was a responsiblity handed to this course, and seeing it all come together is truly fulfilling. 

### Challenges Faced 
1. We had two choices of creating the register file: either use RAM to act as one, or implement one ourselves. I opted for the second option, where my design uses a clever combination of AND gates and combinational logic circuits (both multiplexers and decoders) to allow the control unit to both specify a particular register to read from and write to without affecting the state of other registers. This wasn't that difficult to design, though it's worth highlighting, since it helped me better understand key differences between multiplexers and decoders.
    - Another key requirement was ensuring that the zeroth register (R0) was always zero, no matter what value was written to it. This simply required a multiplexer whose select bits were either always on (my design) or off with it's output forever remaining fixed as a flat 0. The other input was the value within the register.
2. I made a silly mistake by assuming that every value in the immediate offset field of an instruction required signed 1 bits appended to it, always. I quickly realized that this will lead to incorrect computed values when ALU operations are applied and therefore designed a combinational logic circuit that can detect whether the offset should contain all 0s (positive) or all 1s (negative). Knowing that the magnitude of the offset is 5 excluding the signed bit meant that the range is from -16 to 15. Simply apply the output of the *offset* signed bit to the select bit of a 2-to-1 MUX whose inputs 16-bit numbers of either all 0s or 1s with the remaining 5 bits attached to the splitter. Thankfully, this didn't take long to implement in the datapath, nor does it require much circuitry. 
3. We had a choice of either designing the control unit as either a Flat ROM with all addresses and control signals encoded in it, or split it off into 3 ROMs (sequencer ROM) as bonus. I chose to implement the bonus version, since it would force me to learn and appreciate deeper engineering choices when designing a processor. A template of this version of the control unit was provided, and while I didn't fully understand the purpose of this at first, let alone how it differs from Flat ROM, slowly implementing each component made it more clear. The state register simply holds the address of an instruction from one of the 3 ROMs, and each address holds bits to assert certain control signals in each processor state. The sequencer ROM holds the *first* address in the main ROM of each type of instruction for the processor to execute (add, beq, etc.) and the Z ROM holds the *first* address of only two states: no branch (go to fetch0) or branch (continue executing beq instruction). The main ROM contains all the control signals as well as the address of the next state to be executed when either 'OPTest' or 'chkZ' aren't asserted. The choice to load the state register with any given address is faciliated by a 4-to-1 MUX with a single unused input. And the clock is what makes the entire processor function to begin with, since rising edge parts of the clock cycle trigger the state register to be loaded with a new address from any of the ROMs, which continuously runs the processor through new states. Quite a learning experience.
4. All that was left was to write and upload the ROM with the microcode which was fairly simple and straightforward, although my branch instruction wasn't executing quite the way it should have. The branch instruction requires loading the Z register and then checking whether this value is 1 or not. Both of these signals cannot occur on the same clock cycle, because the Z register won't update fast enough to alert the control unit that it should branch in the case that the value on the bus is 0. This led me down a long, arduous path of me debugging my entire datapath for days, because I wanted to achieve an optimal 28 microstate solution. However, I eventually concluded that such a metric seems infeasible with the 3-ROM approach given that while it does save tons of space on the processor compared to Flat ROM, it executes slower due to additional steps for aligning timing.

## Project 2 - Augmenting a 32-bit LC-2200 Datapath to Incorporate Interrupt Handling
NOTE: For Project 1, I used Logisim Evo which is a repurposed version of an older tool, but for Project 2, I transitioned to Circuit Sim due to its compatibility with the Python-based assembler and the shift to a 32-bit architecture.

Overall, this project was quite straightforward and didn't involve much difficulty. The key challenge was understanding how interrupt lines utilize pull-up and pull-down resistors to maintain reliable HIGH and LOW values when idle, and how to simulate this properly in Circuit Sim. Apart from that, the concepts involved in interrupt handling such as the interrupt register, daisy-chaining and interrupt acknowledgement signals being passed to peripheral devices, and save/restoring processor state during interrupt handling all led me to appreciate I/O mechanisms more deeply and thoughtfully.

## Project 3 - Implementing a Memory Management Unit and Page Replacement Algorithms

This project was quite a handful, even more difficult than multithreading. I was forced to thoroughly examine line-by-line using GDB every single bug I encountered on multiple iterations (some of which still remain because I simply lost patience). For instance, one of the first bugs I encountered that took me a fair while to diagnose was the fact that I didn't realize that by returning a pointer to struct and performing pointer arithmetic prior that I was mistakenly performing pointer arithmetic with a pointer to struct, not a pointer to uint16_t for address_splitting.c, which involved calculating PTE and physical memory offsets. This of course led to segfaults due to the fact that the pointer's value was consistently being offset by large, struct-sized chunks of memory, leading me to ultimately conclude that performing a cast after pointer arithmetic to return a struct-sized piece of memory is ultimately necessary. Additionally, it became increasingly clear that I should deeply understand how the code provided the TA's 'simulator-src' was interacting with and calling my code 'student-src', a lesson which I carry over into Project 4. For instance, it wasn't explicitly made clear that PIDs are handled by the TA's code for instance, which caused another headache for some time. But the most frustrating thing was constantly re-writing 'context_switch()' defined in proc.c, because I assumed that it would be necessary to handle a process's entire start-stop behavior. Turns out, it required just two lines of code: 'proc->state = PROC_RUNNING;' and 'PTBR = proc->saved_ptbr;' which sets the new process passed into the function's PCB state to PROC_RUNNING and the global PTBR to that of the new process. Regarding the page replacement algorithms, most were able to be properly implemented, although I ran into issues running some traces. Executing the example command 'diff my_output.log outputs/astar-random.log' would for instance reveal a 5 line difference when the total length of the trace files exceeded 500k lines. Overall, this experience has revealed to me that MMU's are quite prone to corruption and require robust C programming and deep low-level understanding of page-based memory systems. I can only imagine how complicated it becomes in a modern OS.

## Project 4 - Process Scheduling

Not too much to say about this project. We were tasked with implementing the ready queue linked list and all scheduling behavior surrounding it. Additionally, our test cases had to handle the provided variety of scheduling algorithms via command line arguments, so code was written to accomplish that as well. Most time was actually spent studying the behavior of the provided code on the student's behalf in order to precisely understand how the CPUs are being simulated, further refine my threading knowledge and skillset, and diagnose issues that arose when I was implementing the methods in the student.c file. Overall, this was one of the easier projects and seemed quite straightforward, in my experience.

