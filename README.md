# Systems-Programming
This repository showcases my journey through the CS 2200 curriculum, focusing on processor design and systems programming. It includes five projects, each documented with detailed explanations of the design process, challenges faced, and insights gained.

## Project 1 - Implementing a 16-bit LC-2200 Datapath
This was a fun, hands-on way of creating a processor mostly from scratch. While I obtained a general understanding of datapath design from a prerequisite course offered at my college (CS 2110), how the control unit facilitates the processor stepping through sequential, repeatable states remained a mystery to me until now. That was a responsiblity handed to this course, and seeing it all come together is truly fulfilling. 

### Challenges Faced 
1. We had two choices of creating the register file: either use RAM to act as one, or implement one ourselves. I opted for the second option, where my design uses a clever combination of AND gates and combinational logic circuits (both multiplexers and decoders) to allow the control unit to both specify a particular register to read from and write to without affecting the state of other registers. This wasn't that difficult to design, though it's worth highlighting, since it helped me better understand key differences between multiplexers and decoders.
    - Another key requirement was ensuring that the zeroth register (R0) was always zero, no matter what value was written to it. This simply required a multiplexer whose select bits were either always on (my design) or off with it's output forever remaining fixed as a flat 0. The other input was the value within the register.
2. I made a silly mistake by assuming that every value in the immediate offset field of an instruction required signed 1 bits appended to it, always. I quickly realized that this will lead to incorrect computed values when ALU operations are applied and therefore designed a combinational logic circuit that can detect whether the offset should contain all 0s (positive) or all 1s (negative). Knowing that the magnitude of the offset is 5 excluding the signed bit meant that the range is from -16 to 15. Simply apply the output of the *offset* signed bit to the select bit of a 2-to-1 MUX whose inputs 16-bit numbers of either all 0s or 1s with the remaining 5 bits attached to the splitter. Thankfully, this didn't take long to implement in the datapath, nor does it require much circuitry. 
3. We had a choice of either designing the control unit as either a Flat ROM with all addresses and control signals encoded in it, or split it off into 3 ROMs (sequencer ROM) as bonus. I chose to implement the bonus version, since it would force me to learn and appreciate deeper engineering choices when designing a processor. A template of this version of the control unit was provided, and while I didn't fully understand the purpose of this at first, let alone how it differs from Flat ROM, slowly implementing each component made it more clear. The state register simply holds the address of an instruction from one of the 3 ROMs, and each address holds bits to assert certain control signals in each processor state. The sequencer ROM holds the *first* address in the main ROM of each type of instruction for the processor to execute (add, beq, etc.) and the Z ROM holds the *first* address of only two states: no branch (go to fetch0) or branch (continue executing beq instruction). The main ROM contains all the control signals as well as the address of the next state to be executed when either 'OPTest' or 'chkZ' aren't asserted. The choice to load the state register with any given address is faciliated by a 4-to-1 MUX with a single unused input. And the clock is what makes the entire processor function to begin with, since rising edge parts of the clock cycle trigger the state register to be loaded with a new address from any of the ROMs, which continuously runs the processor through new states. Quite a learning experience.
4. All that was left was to write and upload the ROM with the microcode which was fairly simple and straightforward, although my branch instruction wasn't executing quite the way it should have. The branch instruction requires loading the Z register and then checking whether this value is 1 or not. Both of these signals cannot occur on the same clock cycle, because the Z register won't update fast enough to alert the control unit that it should branch in the case that the value on the bus is 0. This led me down a long, arduous path of me debugging my entire datapath for days, because I wanted to achieve an optimal 28 microstate solution. However, I eventually concluded that such a metric seems infeasible with the 3-ROM approach given that while it does save tons of space on the processor compared to Flat ROM, it executes slower due to additional steps for aligning timing.

## Project 2 - Augmenting a 32-bit LC-2200 Datapath to Incorporate Interrupt Handling
NOTE: For Project 1, I used Logisim Evo which is a repurposed version of an older tool, but for Project 2, I transitioned to Circuit Sim due to its compatibility with the Python-based assembler and the shift to a 32-bit architecture.

Overall, this project was quite straightforward and didn't involve much difficulty. The key challenge was understanding how interrupt lines utilize pull-up and pull-down resistors to maintain reliable HIGH and LOW values when idle, and how to simulate this properly in Circuit Sim. Apart from that, the concepts involved in interrupt handling such as the interrupt register, daisy-chaining and interrupt acknowledgement signals being passed to peripheral devices, and save/restoring processor state during interrupt handling all led me to appreciate I/O mechanisms more deeply and thoughtfully.
